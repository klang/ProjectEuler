(ns problem297
  (meta {:description "Each new term in the Fibonacci sequence is generated by adding the previous two terms.
Starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89.

Every positive integer can be uniquely written as a sum of nonconsecutive terms of the Fibonacci sequence. For example, 100 = 3 + 8 + 89.
Such a sum is called the Zeckendorf representation of the number.

For any integer n>0, let z(n) be the number of terms in the Zeckendorf representation of n.
Thus, z(5) = 1, z(14) = 2, z(100) = 3 etc.
Also, for 0<n<10^6, ∑ z(n) = 7894453.

Find ∑ z(n) for 0<n<10^17."
	 :observations "F83 < 10^17 < F84"})
  (:use clojure.contrib.lazy-seqs
	[clojure.contrib.seq-utils :only (indexed)]
	clojure.contrib.math
	clojure.test))

(defn flatten-once [s] (remove seq? (tree-seq seq? seq s)))
(def hard-fibs (into [] (take-while #(< %(expt 10 17)) (drop 2 (fibs)))))
(def hard-fibs-reverse (into [] (reverse (take-while #(< %(expt 10 17)) (drop 2 (fibs))))))

(defn zeckendorf-hard [number]
  "returns the zeckendorf representation of a number, based on a hardcoded list"
  (loop [number number catch (transient [])]
    (if (zero? number) (persistent! catch)
      (let [n (first (drop-while #(< number %) hard-fibs-reverse))]
	(recur (- number n) (conj! catch n))))))

(defn zeckendorf-terms-hard [number]
  "returns the number of terms in the zeckendorf representation of a number, based on a hardcoded list"
  (loop [number number terms 0]
    (if (zero? number) terms
      (let [n (first (drop-while #(< number %) hard-fibs-reverse))]
	(recur (- number n) (inc terms))))))

(deftest test-zeckendorf-hard 
  (is (= [89 8 3] (zeckendorf-hard 100)))
  (is (= 3 (zeckendorf-terms-hard 100))))

(defn zeckendorf [number]
  "returns the zeckendorf representation of a number"
  (loop [number number catch (transient [])]
    (if (zero? number) (persistent! catch)
      (let [n (last (take-while #(<= % number) (fibs)))]
	(recur (- number n) (conj! catch n))))))

(defn zeckendorf-terms [number]
  "returns the number of terms in the zeckendorf representation of a number"
  (loop [number number terms 0]
    (if (zero? number) terms
      (let [n (last (take-while #(<= % number) (fibs)))]
	(recur (- number n) (inc terms))))))

(deftest test-zeckendorf 
  (is (= 1 (zeckendorf-terms 5)))
  (is (= 2 (zeckendorf-terms 14)))
  (is (= 3 (zeckendorf-terms 100)))
  (is (= [89 8 3] (zeckendorf 100)))
  (is (= 3 (zeckendorf-terms 100)))
  #_(is (= 7894453
	   (reduce + (take (expt 10 6) 
			   (map #(zeckendorf-terms-hard %) 
				(iterate inc 1)))))))

(defn F [n]
  "Stack consuming fibo, Programming Clojure, p.133"
  (cond 
    (<= n 0) 0
    (= n 1) 1
    :else
    (+ (F (- n 1)) (F (- n 2)))))

(defn Zr [n]
  "Stack consuming Sum of Zeckendorf-terms" 
  (cond
    (= n 0) 1
    (= n 1) 1
    :else
    (+ (Zr (- n 1)) (Zr (- n 2)) (F (- n 1)))))

(defn fibos []
  "Christophe Grand's lazy fibonacci sequence, also available in clojure.contrib.lazy-seqs"
  (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1])))

(defn Z []
  "returns the sum of the number of terms in fibonacci points"
  (map first (iterate (fn [[z2 z1 f2 f1 ]] [z1 (+ z2 z1 f1) f1 (+ f2 f1)]) [1 1 0 1])))

(deftest test-Zzz
  (is (= (map #(Zr %) (range 0 14))
	 '(1 1 3 5 10 18 33 59 105 185 324 564 977 1685)
	 (take 14 (Z)))))

(defn find-index [fib-num]
  "find the index of a given fibonacci number" 
  (first (first (filter #(= (second %) fib-num) (indexed hard-fibs)))))

;; what is the correct index?

(comment
  (defn find-index [fib-num]
    "find the index of a given fibonacci number" 
    (first (first (filter #(= (second %) fib-num) (indexed (fibs)))))))

(deftest test-zeckendorf-sums
  (is (= (reduce + (take 987 (map #(zeckendorf-terms-hard %) (iterate inc 1))))
	 3971)))
  ;; 1-1000  = 4005
  ;; 1-10000 = 52816
  ;; 1-20000 = 113037
  ;; 1-100000= 658212
  (comment
)
  ;; when the target is a fibonacci number 
  (is (= (reduce + (take (dec 987) (map #(zeckendorf-terms-hard %) (iterate inc 1))))
	 (reduce + [1 1 3 5 10 18 33 59 105 185 324 564 977 1685])
	 3970
	 (reduce + (take 14 (Z)))
	 (reduce + (take (find-index 987) (Z)))))
  ;; when the target is not a fibonacci number
  (is (= (nth (Z) (inc (find-index  (- 1000 (last (take-while #(<= % 1000) (fibs)))))))
	 33
	 (+ 1 2 2 2 3 2 3 3 2 3 3 3 4)))
  ;; 
  (is (= (reduce + (take (dec 1000) (map #(zeckendorf-terms-hard %) (iterate inc 1))))
	 4003
	 (+ 3970 33)
	 ;; (zeckendorf-hard 1000) => [987 13]
	 (+ (reduce + (take (find-index 987) (Z)))
	    (nth (Z) (inc (find-index 13))))
	 ))
  ;;
  (is (= (reduce + (take (dec 1025) (map #(zeckendorf-terms-hard %) (iterate inc 1))))
	 4086
	 (+ 3970 105 11)
	 ;; (zeckendorf-hard 1025) => [987 34 3 1]
	 (+ (reduce + (take (find-index 987) (Z)))
	    (nth (Z) (inc (find-index 34)))
	    11 
	    ;; some calculation based on 3
	    ;; some calculation based on 1
	    )))

  (is (= (reduce + (take 100 (map #(zeckendorf-terms-hard %) (iterate inc 1))))
	 (+ (+ 1                                                                      ;1
	       1                                                                      ;2  
	       1 2                                                                    ;3 
	       1 2 2                                                                  ;5
	       1 2 2 2 3                                                              ;8
	       1 2 2 2 3 2 3 3                                                        ;13 
	       1 2 2 2 3 2 3 3 2 3 3 3 4                                              ;21
	       1 2 2 2 3 2 3 3 2 3 3 3 4 2 3 3 3 4 3 4 4                              ;34 
	       1 2 2 2 3 2 3 3 2 3 3 3 4 2 3 3 3 4 3 4 4 2 3 3 3 4 3 4 4 3 4 4 4 5)   ;55
	    ;; only 88 terms in the sum above
	    ;; the term for 89 is the first term (1) in the next group
	    ;; 
	    (+ 1 2 2 2 3 2 3 3                                                        
	       2 3 3 3))                                                              ;89
	 ;; --- for that reason, there is one term too much in the last one
	 (+ 235 18 11)
	 264
	 ;; (zeckendorf-hard 100) => [89 8 3]
	 (+ (reduce + (take (find-index 89) (Z)))
	    (nth (Z) (inc (find-index 8)))
	    ;; ---> the group that starts from the 9th fibo
	    (reduce + (take (+ 3 1) (partial-group (inc (find-index 89)))))
	    ;; some calculation based on 3 that adds up to 11
	    ;; ok, why add one?
	    )
	 ) 
        (let [z100    '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 
			26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 
			51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 
			76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100)
	    z88     '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 
			26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 
			51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 
			76 77 78 79 80 81 82 83 84 85 86 87 88)
	    z89_8   '(89 90 91 92 93 94 95 96)
	    z89_8_3 '(97 98 99 100)
	    ]
	(= (reduce + (map #(zeckendorf-terms-hard %) z100))
	   (+ (reduce + (map #(zeckendorf-terms-hard %) z88))
	      (reduce + (map #(zeckendorf-terms-hard %) z89_8))
	      (reduce + (map #(zeckendorf-terms-hard %) z89_8_3)))
	   (+ (reduce + (take (find-index 89) (Z)))
	      (nth (Z) (inc (find-index 8)))
	      (reduce + (map #(zeckendorf-terms-hard %) z89_8_3)))
	   (+ 235 18 11))))
  

  ;;
  (comment
    (is (= (reduce + (take 32 (map #(zeckendorf-terms-hard %) (iterate inc 1))))
	   67
	   ;; (zeckendorf-hard 32) => [21 8 3]
	   (+ (reduce + (take (find-index 21) (Z)))
	      (nth (Z) (inc (find-index 8)))
	      (+ (nth (Z) (inc (find-index 3))) (inc (find-index 3)) 
		 3)
	      #_(reduce + (take (+ 3 1) (partial-group (inc (find-index 21))))))))

    (is (= (reduce + (take 10000 (map #(zeckendorf-terms-hard %) (iterate inc 1))))
	   52816
	   ;; (zeckendorf-hard 10000) => [6765 2584 610 34 5 2]
	   (+ 34690 14406 3720)
	   (+ (reduce + (take (find-index 6765) (Z)))
	      (nth (Z) (inc (find-index 2584)))
	      (+ (+ (nth (Z) (inc (find-index 610))) 610)
		 (+ (nth (Z) (inc (find-index 34))) (* 2 34))
		 (+ (nth (Z) (inc (find-index 5))) (* 3 5))
		 (+ (nth (Z) (inc (find-index 2))) (* 4 2)))
	      6 ;; <---- (zeckendorf-terms 10000)
	      ;;(- 3720 2909) 811
	      #_(reduce + (take (+ 610 34 5 2 1) (partial-group (inc (find-index 6765)))))
	      )))

    ;; --- something is wrong with the way we calulate the initial terms
    ;; (reduce + (take (find-index 6765) (Z))) only contains the sum of 6764 terms
    ;; (nth (Z) (inc (find-index 2584)))       contains the sum of 2584 terms
    ;; there should only be (+ 610 34 5 2) terms left, but there is one more term

    (is (= 7894453
	   ;;(zeckendorf-hard (expt 10 6)) => [832040 121393 46368 144 55]
	   (+ (reduce + (take (find-index 832040) (Z)))
	      (nth (Z) (inc (find-index 121393)))
	      (+ (+ (nth (Z) (inc (find-index 46368))) 46368)
		 (+ (nth (Z) (inc (find-index 144))) (* 2 144))
		 (+ (nth (Z) (inc (find-index 55))) (* 3 55)))
	      ;;(reduce + (take (+ 46368 144 55) (partial-group (inc (find-index 832040))))))
	      ;;382970
	   ))))

(defn partial-group [nth-fib]
      (take (- (nth (fibos) nth-fib) (nth (fibos) (dec nth-fib)))
	    (map #(zeckendorf-terms-hard %) (iterate inc (+ (nth (fibos) (inc nth-fib))
							    (nth (fibos) (dec nth-fib)))))))

(defn Ze [number]
  (let [z (zeckendorf-hard number)
	r (reduce + (subvec (zeckendorf-hard number) 2))]
    (+ (reduce + (take (find-index (first z)) (Z)))
       (nth (Z) (inc (find-index (second z))))
       (reduce + (take (+ r 1) (partial-group (inc (find-index (first z)))))))))

(defn zelastpart [coll]
  (loop [c coll i 1 sum 0]
    (if (empty? c )
      sum
      (recur (rest c) (inc i) (+ sum (+ (nth (Z) (inc (find-index (first c)))) (* i (first c))))))))

(defn Zef [number]
  (let [z (zeckendorf-hard number)
	r (subvec (zeckendorf-hard number) 2)]
    (+ (reduce + (take (find-index (first z)) (Z)))
       (nth (Z) (inc (find-index (second z))))
       (zelastpart r))))

(deftest test-Ze
  (is (= 4005 (Ze 1000)))
  (is (= 52816 (Ze 10000)))
  (is (= 113037 (Ze 20000)))
  (is (= 658212 (Ze 100000))))

(deftest test-zef
  (is (= 7894453 (Zef 1000000))))


(comment
  (defn F [n] (nth hard-fibs (dec n)))
  (take (- 987 609) (drop 610 (map #(zeckendorf-terms-hard %) (iterate inc 1))))
  ;; the 377 terms in the group from 610 to 987
  (count (take (- 986 609) (drop 609 (map #(zeckendorf-terms-hard %) (iterate inc 1)))))
  (nth hard-fibs 5))

(comment
  (defn find-index [fib-num]
    "find the index of a given fibonacci number" 
    (inc (first (first (filter #(= (second %) fib-num) (indexed hard-fibs)))))))

(defn group [nth-fib]
  "returns the length of the zeckendorf terms for the group leading up to the nth fibonacci number.
Counting from zero in [1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 .. ]"
  (take (- (dec (nth hard-fibs nth-fib)) 
	   (dec (nth hard-fibs (dec nth-fib))))
	(drop (dec (nth hard-fibs (dec nth-fib)))
	      (map #(zeckendorf-terms-hard %) (iterate inc 1)))))

;; do we have to iterate from 1?
(defn group [nth-fib]
  "returns the length of the zeckendorf terms for the group leading up to the nth fibonacci number.
Counting from zero in [1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 .. ]"
  (take (- (dec (nth hard-fibs nth-fib)) 
	   (dec (nth hard-fibs (dec nth-fib))))
	(map #(zeckendorf-terms-hard %) (iterate inc (dec (nth hard-fibs (dec nth-fib)))))))

(defn group [nth-fib]
  "returns the length of the zeckendorf terms for the group leading up to the nth fibonacci number.
Counting from zero in [1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 .. ]"
  (take (- (dec (nth hard-fibs nth-fib)) 
	   (dec (nth hard-fibs (dec nth-fib))))
	(map #(zeckendorf-terms-hard %) (iterate inc (nth hard-fibs (dec nth-fib))))))

(comment
  (def g14 (group 14))
  (reduce + (flatten-once (map #(take % g14) [1 1 2 3 5 8 13 21 34 55 89 144 233 377])))
  ;; 3970
  (reduce + (take 986 (map #(zeckendorf-terms-hard %) (iterate inc 1))))
  ;; 3970
  (first (reverse (take-while #(< %(expt 10 6)) (drop 2 (fibs)))))
  ;;832040
)


(comment
  ;; the first fibonacci number under (expt 10 6)
  (def g29 (group (find-index 832040)))
  (reduce + (flatten-once (map #(take % g29) [1 1 2 3 5 8 13 21 34 55 89 144 233 377])))
  ;; 3970
  (reduce + (flatten-once (map #(take % g29) (lazy-cat '(1) (take (- (find-index 832040) 2) hard-fibs)))))
  ;; taking a group of almost a million number takes too long
)

(time (run-tests))

